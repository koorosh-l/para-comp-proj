* Introduction
This repository contains the first phase of our project for parallel computing project.
The goal is to create two randomly sized matrices field with random elements called M1 and M2, and compute a third matrix called M3 with dimensions equal to m1 using the following formula:

M_{3}[i][j] = \sum_{x = 0}^{M_2.j} \sum_{y}^{M_2.i} M_2[x][y] \times M_1[i+x][j+y]

* Running
compile with
#+begin_src shell
  make
  ./ugly
  ./phase1
  ./phase2
#+end_src
phase1 is the algorithm written linearly.


phase2 is a nice parallel form of the algorithm which distributes the jobs evenly across the number of threads returned by nproc.

ugly is the parallel version as specified in the phase2 doc.

unfortunately I don't think there is a good way of rewriting so that we are not always blocking one might create another thread that prints m3 repeatedly (and clears) the screen but the operation is finishes really fast and so the changes are not predictably visible in the outputs and solving this issue requires so much locking that our program is going to be sequential, also if the dimensions of m1 are too big then program always segfaults since para_matrix_map defines and array of threads on the stack, this can be fixed but realistically how plausible is it that we might want to create one thread for each cell of m1.

* internals
There are three source files in src proj.c is the actual code for the project and targets ugly, phase2 and phase1 are compiled from this file, matrix.c and matrix.h define a tiny matrix library, matrix.c compiles to libmatrix.so and output binaries are dynamically linked against this library(using -rpath so we don't have to modify LD_LIBRARY_PATH).

** libmatrix.so
libmatrix.so is written in a way that functions and structures don't assume anything about the size of the fields of our matrix so we can easily store any data type in there even other matrices.

*** functions
**** create_matrix

Returns: Matrix Pointer
Arguments: row_c, column_c, memb

Initializes a pointer of type "matrix" and allocates memory for it. It sets the matrix pointer fields equal to the arguments passed to the function and returns a pointer to the newly created matrix.

**** free_matrix

Returns: No return value
Arguments: Matrix Pointer

Free's the memory allocated to matrix pointer.

**** matrix_copy

Returns: Matrix Pointer
Arguments: Matrix Pointer

Returns a newly created matrix with the same exact field values as the matrix passed to the function.

**** matref
**** matrix_map
**** para_matrix_map

*** macros
**** MATSIZE

Arguments: row_c, column_c

It expands to an expression used to calculate the number of elements
in the matrix.

**** MATBYTES

Arguments: row_c, column_c, memb

It expands to an expression used to calculate the size of the matrix
in bytes

**** deb
*** structs
**** matrix

Fields: row_c, column_c, memb, mat;

Defines a struct that stores the pointer to a matrix, its row and column sizes,
and the size of the matrix members in bytes. 


**** interval

** makefile

*** Variables
COMP_FLAGS := -g -lpthread -march=native
NPROC :=$(shell nproc)

*** all
**** Dependencies: phase2, phase1, ugly

Compiles the following phase targets: phase2, phase1, ugly

*** ugly
**** Dependencies: ugly.o

Invokes gcc and links the ugly.o object file into an executable.  

*** ugly.o
**** Dependencies: src/proj.c, libmatrix.so

Invokes gcc and compiles the source file, without linking, into an object file.
Defines UGLY to run ugly.

*** phase2
**** Dependencies: phase2.o

Invokes gcc and links the phase2.o file into an executable.

*** phase2.o
**** Dependencies: src/proj.c, libmatrix.so

Invokes gcc and compiles the source file, without linking, into an object file.
Defines NPROC to run Phase 2 of the project.

*** phase1
**** Dependencies: phase1.o

Invokes gcc and links the phase1.o object file into an executable.

*** phase1.o
**** Dependencies: src/proj.c, libmatrix.so

Invokes gcc and compiles the source file, without linking, into an object file.
Defines P1 to run Phase 1 of the project.

*** libmatrix.so
**** Dependencies: libmatrix.o

Invokes gcc and uses the -shared compiler flag to produce a shared object which can then be linked with other objects to form an executable called "libmatrix.so".

*** libmatrix.o
**** Dependencies: src/matrix.c, src/matrix.h

Invokes gcc and compiles matrix.c, without linking, into an object file called "libmatrix.o". Calls -Wall and -fPIC compiler flags, to show all warnings, and makes sure the executable is independent of the position of libraries  in memory, respectively.

*** clean
**** Dependencies: 

Invokes rm and removes all files produced by the makefile. 

** proj.c

